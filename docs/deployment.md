# Multicloud E-Commerce Demo: Detailed Deployment Plan

This document provides a comprehensive, step-by-step deployment playbook outlining how to provision the entire Multi-Cloud E-Commerce architecture. It is designed for Google Software Engineers (SWEs) and Cloud Architects aiming to deploy this demonstration natively into their own distinct Google Cloud Projects.

Due to the complex interdependencies between decoupled VPC environments, Serverless integrations, and multi-cloud telemetry routing, the infrastructure *must* be deployed in a highly specific phase sequence.

---

## üèóÔ∏è Deployment Order Strategy

To prevent race conditions‚Äîsuch as a Cloud Run container failing to boot because its required Direct VPC Egress target subnet does not yet exist‚Äîthe deployment targets foundational network fabrics first before introducing operational logic nodes.

### Phase Sequence Summary:
1. **[Phase 1]** Base Prerequisites & IAM API enablement
2. **[Phase 2]** External Multi-Cloud Dependencies (Azure Fraud Engine)
3. **[Phase 3]** Foundational Networking & Core GKE Clusters
4. **[Phase 4]** Legacy Compute & VPC Segregation (VMs & PSC)
5. **[Phase 5]** Asynchronous Backbone & Serverless Fleet (Cloud Run & Pub/Sub)
6. **[Phase 6]** Storefront Orchestrator Injection & GKE Application Rollout

---

## üìë Detailed Execution Instructions

### Phase 1: Prerequisites & Environmental Setup
Before firing infrastructure-as-code (IaC) pipelines, the target Google Cloud Project shell must be configured.

1. **Allocate a Clean Project:** Establish a new, isolated GCP Project exclusively for this demo to ensure global firewall testing does not interfere with personal or team development environments.
2. **Enable Billing:** Ensure an active Cloud Billing instrument is strictly linked.
3. **Enable Core APIs:** Utilize `gcloud` to enable all underlying primitives required by Terraform.
   ```bash
   gcloud services enable \
     compute.googleapis.com \
     container.googleapis.com \
     run.googleapis.com \
     pubsub.googleapis.com \
     apigee.googleapis.com \
     aiplatform.googleapis.com \
     vpcaccess.googleapis.com \
     dns.googleapis.com
   ```

### Phase 2: Microsoft Azure Environment (Fraud Engine)
*Why deploy this first?* The synchronous Checkout frontend mathematically requires the actual IP address or API gateway URL of the Azure Fraud Engine embedded within its active variables before it can successfully complete a transaction.

1. Navigate to the `/multicloud/azure/terraform/` directory.
2. Authenticate the Azure CLI.
3. Execute `terraform apply` to provision the Azure Virtual Network and the Node.js Fraud Detection VMs.
4. **Action Required:** Capture the `fraud_engine_public_ip` generated by the Terraform output block statically.

### Phase 3: GCP Foundations (VPC & GKE)
The core frontend workloads and the overarching centralized DNS logic must be structurally established to supply Private Service Connect (PSC) bindings.

1. Navigate to the core module: `/multicloud/gcp/terraform/`.
2. Terraform provisions the monolithic `online-boutique-vpc`, establishing rigorous restrictive baseline firewall rules actively dropping public ingress unconditionally.
3. Terraform generates the `online-boutique-cluster` (GKE Autopilot) to act as the primary operational orchestration house securely.
4. The centralized private **Cloud DNS** zone (`internal.boutique.local`) is securely instantiated over the localized subnets. 

### Phase 4: Legacy Segregation & Network Perimeters (VMs)
*Why deploy this now?* The backend monolithic services must be logically running and mapped behind Internal Load Balancers before the Serverless workflows can reach backward attempting synchronous `GET` queries securely. 

1. Within the active Terraform pipeline (`crm.tf` & `inventory.tf`), the automation carves out explicitly decoupled VPCs: `crm-vpc` and `inventory-vpc`.
2. Compute Engine Managed Instance Groups natively boot the legacy Node.js monolith integrations natively executing backend business profiles.
3. The vital isolation networking primitives fire sequentially:
   * **Private Service Connect (PSC)** Service Attachments are logically glued directly to the Inventory VM's TCP internal load balancers. 
   * **PSC Endpoints** are inherently spawned directly traversing backward inside the main `online-boutique-vpc` strictly allowing isolated ingress exclusively for the target endpoints.

### Phase 5: Asynchronous Scale-Out (Pub/Sub & Cloud Run)
*Why deploy this now?* The serverless layers must physically bind virtual NICs into the VPCs created in Phase 4.

1. Terraform establishes the `OrderConfirmed` domain topics and associated Push Subscriptions inside Google Cloud Pub/Sub autonomously.
2. The Accounting, Warehouse, and OrderManagement Docker configurations are fundamentally deployed into managed Google Cloud Run endpoints.
3. Strict Extranet networking rules apply inherently:
   * **Direct VPC Egress** bindings latch the Warehouse container strictly towards the `inventory-vpc` explicitly for native stock editing safely.
   * **Serverless VPC Access Connectors** are fundamentally activated bridging the Accounting service toward the underlying legacy `crm-vpc` internal addresses efficiently.

### Phase 6: Application Composition (Storefront Front-End Rollout)
The final stage bridges the compiled IP addresses mapped from across all structural architectures exclusively into the isolated GKE runtime application stack securely.

1. Extract all underlying IPs and private FQDNs from the raw Terraform state.
2. Inject these parameters permanently inside the `multicloud/checkout-config/checkoutservice-config.yaml` matrix natively. 
   *(e.g., Ensure the `FRAUD_ENGINE_URL` explicitly points natively to the Azure target).*
3. Apply the overarching Kubernetes definitions natively across the GKE Autopilot footprint natively using `kubectl apply -f release/kubernetes-manifests.yaml`.

---

## ‚úÖ Verification & Auditing Protocols

Once the foundational layers successfully finalize deployment, execute the following explicit audits securely enforcing operational success inherently.

### 1. External Public Ingress Verification (Load Balancing)
*   **Action:** Locate the `EXTERNAL_IP` mapped structurally onto the frontend `frontend-external` Service.
*   **Test:** Navigate securely in a web browser. Verify the "Online Boutique" storefront uniquely renders accurately without rendering missing UI graphics intrinsically.

### 2. Zero-Trust Interaction Audit (Private Service Connect)
*   **Action:** Initiate an active test purchase natively traversing the browser frontend globally to completion.
*   **Test:** Navigate directly to Google Cloud Logging. Query explicitly for the `inventory-service` VM logs natively. 
*   **Verification:** Confirm that the logged upstream client IP inherently matches the established localized `/24` private Class-C subnet allocated intrinsically across the PSC Endpoint specifically, *not* a generic public NAT generalized gateway address dynamically.

### 3. Serverless Extranet Routing Audit 
*   **Action:** Evaluate the finalized Cloud Run logs mapping to the overarching `Accounting Service` specifically.
*   **Verification:** Ensure explicit execution traces display successful 200 HTTP responses logically returning correctly natively across internal RPC channels pointing toward the monolithic active CRM Node.js service intrinsically running locally behind its isolated internal TCP Load Balancer flawlessly.

### 4. Multi-Cloud Synchronous Ping
*   **Action:** Examine the telemetry arrays logging active payloads physically inside the deployed Azure Fraud Engine.
*   **Verification:** Confirm explicit JSON payloads capturing `{ transactionType, duration }` arrays properly streamed sequentially over active Interconnect logic successfully terminating from localized generic GCP workloads externally.
